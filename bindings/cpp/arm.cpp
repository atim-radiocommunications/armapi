// ---------------------------------------------------------------------
// This file is generated by armfuser from the c source file.
// Please do not edit this file.
// Generation date: Sep 26 2016 
// ---------------------------------------------------------------------

/***********************************************************************

 Copyright (c) 2016 ATIM
 
 
 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:
 
 
 The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.
 
 
 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.

***********************************************************************/

#include "arm.h"
#ifndef __DOXYGEN__
#define _ARM_TIME_RESET 				10		//10ms
#define _ARM_TIME_TIMEOUT 				20		//20ms
#define _ARM_TIME_BACK_AT				100		//100ms
#define _ARM_TIME_SF_UPLINK_TIMEOUT		10000	//10s
#define _ARM_TIME_SF_DOWNLINK_TIMEOUT	45000	//45s
#define _ARM_TIME_BOOTING				20		//20ms
#define _ARM_NUMBER_OF_TRIALS_GO_AT 	35
#define _ARM_SIGFOX_PAYLOAD_MAX			12
#define _ARM_SIGFOX_PAYLOAD_DOWNLINK	8
#define _ARM_RF_PAYLOAD_MAX				120
#define _ARM_MIN_CHANNEL				1
#define _ARM_MAX_CHANNEL				559
#define _ARM_MIN_RADIO_POWER			(-18)
#define _ARM_MAX_LONG_PREAMBLE_TIME		900
#define _ARM_MAX_POST_TIME				2550
#define _ARM_BASE_DEC					10
#define _ARM_BASE_HEX					16
#define _ARM_IMP1(t1) if(this->_type & (ARM_TYPE_##t1))
#define _ARM_IMP2(t1, t2) if(this->_type & (ARM_TYPE_##t1|ARM_TYPE_##t2))
#define _ARM_REG8_INIT(armType, regType, regName) \
	this->_##armType.regs##regType[_ARM_##armType##_IREG##regType##_##regName].reg=_ARM_##armType##_REG##regType##_##regName
#define _ARM_REG16_INIT(armType, regType, regName) \
	this->_##armType.regs##regType[_ARM_##armType##_IREG##regType##_##regName##_LSB].reg=_ARM_##armType##_REG##regType##_##regName##_LSB; \
	this->_##armType.regs##regType[_ARM_##armType##_IREG##regType##_##regName##_MSB].reg=_ARM_##armType##_REG##regType##_##regName##_MSB
#define _ARM_REG8(armType, regType, regName) \
	this->_##armType.regs##regType[_ARM_##armType##_IREG##regType##_##regName].newVal
#define _ARM_REG16_GET(armType, regType, regName, var)												\
	(var) = this->_##armType.regs##regType[_ARM_##armType##_IREG##regType##_##regName##_MSB].newVal;	\
	(var)<<=8;																						\
	(var) |= this->_##armType.regs##regType[_ARM_##armType##_IREG##regType##_##regName##_LSB].newVal
#define _ARM_REG16_SET(armType, regType, regName, val)												\
	this->_##armType.regs##regType[_ARM_##armType##_IREG##regType##_##regName##_LSB].newVal = (val);	\
	this->_##armType.regs##regType[_ARM_##armType##_IREG##regType##_##regName##_MSB].newVal = (val)>>8
#if !defined ARM_WITH_N8_LPLD && !defined ARM_WITH_N8_LW
#error "ERROR: No arm is declared, please defined ARM_WITH_N8_LPLD or ARM_WITH_N8_LW or both in armconfig.h file."
#endif

#endif //__DOXYGEN__

Arm::Arm()
{
}

Arm::~Arm()
{
}

armError_t Arm::Init(void* port)
{	
	//Initialize the structure
	
		this->_type = ARM_TYPE_NONE;
	
	//Open the uart port
	if(this->_port.Open(port) == -1)
		return ARM_ERR_PORT_OPEN;

	if(this->_port.Config(ARMPORT_BAUDRATE_19200,
									ARMPORT_DATA_8BITS,
									ARMPORT_PARITY_NO,
									ARMPORT_STOPBIT_1) == -1)
		return ARM_ERR_PORT_CONFIG;
	
	//Reboot the arm
	return this->Reboot();
}

armError_t Arm::DeInit()
{
	if(this->_port.Close() == -1)
		return ARM_ERR_PORT_CLOSE;
		
	this->_type = ARM_TYPE_NONE;
	return ARM_ERR_NONE;
}

armError_t Arm::Reboot()
{
	armError_t err = ARM_ERR_NONE;
	
	#ifdef ARMPORT_WITH_nSLEEP
	//nSLEEP to '1'
	this->_port.GpioSet(ARMPORT_PIN_nSLEEP, true);
	#endif
	
	#ifdef ARMPORT_WITH_nBOOT
	//nBOOT to '1'
	this->_port.GpioSet(ARMPORT_PIN_nBOOT, true);
	#endif
	
	#ifdef ARMPORT_WITH_nRESET
		//Reboot by pin
		this->_port.GpioSet(ARMPORT_PIN_nRESET, false);
		this->_port.Delay(_ARM_TIME_RESET);
		this->_port.GpioSet(ARMPORT_PIN_nRESET, true);
	#else
		//No need rebooting because initialization (type == ARM_TYPE_NONE)
		if(this->_type != ARM_TYPE_NONE)
		{
			//Go to AT commend to reboot.
			err = this->_GoAt();
			if(err != ARM_ERR_NONE)
				return err;
			
			//Reboot by "ATR" if ARM is already initialized/used/...
			if(this->_port.Write("ATR\n", 4) != 4)
				return ARM_ERR_PORT_WRITE;
		}
	#endif
	
	//Wait booting
	this->_port.Delay(_ARM_TIME_BOOTING);
	
	#ifdef ARM_WITH_N8_LPLD
		_ARM_IMP2(N8_LP, N8_LD)
		{
			#ifdef ARMPORT_WITH_nBOOT
				//nBOOT to '0'
				this->_port.GpioSet(ARMPORT_PIN_nBOOT, false);
			#else
				//Wait booting
				if(this->_type != ARM_TYPE_NONE)
					this->_port.Delay(_ARM_N8LPLD_TIME_BOOTING);
			#endif
		}
	#endif
	
	//Configure the port
	if(this->_port.Config(ARMPORT_BAUDRATE_19200,
									ARMPORT_DATA_8BITS,
									ARMPORT_PARITY_NO,
									ARMPORT_STOPBIT_1) == -1)
		return ARM_ERR_PORT_CONFIG;
		
	//Get info to get ARM type
	err = this->Info(&this->_type, NULL, NULL, NULL, NULL);
	if(err != ARM_ERR_NONE)
		return err;
		
	//Init registers	
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		_ARM_REG8_INIT (N8LPLD, H, APPLICATION1);
		_ARM_REG16_INIT(N8LPLD, H, CHANNEL1);
		_ARM_REG8_INIT (N8LPLD, H, POWER);
		_ARM_REG8_INIT (N8LPLD, H, RADIO_BAUDRATE);
		_ARM_REG8_INIT (N8LPLD, H, SERIAL_BAUDRATE);
		_ARM_REG8_INIT (N8LPLD, H, SERIAL_DATABITS);
		_ARM_REG8_INIT (N8LPLD, H, SERIAL_PARITY);
		_ARM_REG8_INIT (N8LPLD, H, SERIAL_STOPBIT);
		_ARM_REG8_INIT (N8LPLD, H, BRIDGE_SETTING);
		_ARM_REG8_INIT (N8LPLD, H, ON_BOARD);
		_ARM_REG16_INIT(N8LPLD, H, CHANNEL2);
		_ARM_REG8_INIT (N8LPLD, H, RSSI_LEVEL);
		_ARM_REG16_INIT(N8LPLD, H, NSAMPLE);
		_ARM_REG8_INIT (N8LPLD, H, USER_GAIN);
		_ARM_REG8_INIT (N8LPLD, H, WAKE_UP_PWR);
		_ARM_REG8_INIT (N8LPLD, H, WAKE_UP_RF);
		_ARM_REG16_INIT(N8LPLD, H, LONG_PREAMBLE);
		_ARM_REG8_INIT (N8LPLD, H, POST_TIME);
		_ARM_REG8_INIT (N8LPLD, H, REMOTE_ADDRESS);
		_ARM_REG8_INIT (N8LPLD, H, SETTING1);
		_ARM_REG8_INIT (N8LPLD, H, SETTING2);
		_ARM_REG8_INIT (N8LPLD, H, LOCAL_ADDRESS);
	}
	#endif
	
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		_ARM_REG8_INIT (N8LW, M, CONFIGURATION);
		_ARM_REG8_INIT (N8LW, M, LOW_POWER);
		_ARM_REG8_INIT (N8LW, M, LED);
		
		_ARM_REG8_INIT (N8LW, O, TXRX2_SF);
		_ARM_REG8_INIT (N8LW, O, POWER);
		_ARM_REG8_INIT (N8LW, O, TXRX2_CHANNEL);
		_ARM_REG8_INIT (N8LW, O, CONFIRMED_FRAME);
		_ARM_REG8_INIT (N8LW, O, PORT_FIELD);
		_ARM_REG8_INIT (N8LW, O, CONFIG);
	}
	#endif
	
	//Go to AT commend for get register
	err = this->_GoAt();
	if(err != ARM_ERR_NONE)
		return err;
	
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		int i = 0;
		
		//Read all S register from arm
		for(i=0; i<_ARM_N8LPLD_REGH_SIZE; i++)
		{
			err = this->_GetReg('H', this->_N8LPLD.regsH[i].reg, &this->_N8LPLD.regsH[i].val);
			if(err != ARM_ERR_NONE)
				return err;
			this->_N8LPLD.regsH[i].newVal = this->_N8LPLD.regsH[i].val;
		}
		
		//Set UART to RF Mode in Application register.
		_ARM_REG8(N8LPLD, H, APPLICATION1) = _ARM_N8LPLD_REGH_APPLICATION1_UART_RF;
		#ifdef ARMPORT_WITH_nSLEEP
			//Enable Wake up on the sleep pin
			_ARM_REG8(N8LPLD, H, WAKE_UP_PWR) |=  _ARM_N8LPLD_REGH_WAKE_UP_PWR_INT0;
		#else
			//Disbale Wake up on the sleep pin
			_ARM_REG8(N8LPLD, H, WAKE_UP_PWR) &=  ~_ARM_N8LPLD_REGH_WAKE_UP_PWR_INT0;
		#endif
	}
	#endif
	
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		int i = 0;
		
		//Read all M register from arm
		for(i=0; i<_ARM_N8LW_REGM_SIZE; i++)
		{
			err = this->_GetReg('M', this->_N8LW.regsM[i].reg, &this->_N8LW.regsM[i].val);
			if(err != ARM_ERR_NONE)
				return err;
			this->_N8LW.regsM[i].newVal = this->_N8LW.regsM[i].val;
		}
		
		//Read all O register from arm
		for(i=0; i<_ARM_N8LW_REGO_SIZE; i++)
		{
			err = this->_GetReg('O', this->_N8LW.regsO[i].reg, &this->_N8LW.regsO[i].val);
			if(err != ARM_ERR_NONE)
				return err;
			this->_N8LW.regsO[i].newVal = this->_N8LW.regsO[i].val;
		}
		
		#ifdef ARMPORT_WITH_nSLEEP
			//Enable Wake up on the sleep pin
			_ARM_REG8(N8LW, M, LOW_POWER) |=  _ARM_N8LW_REGM_LOW_POWER_ENABLE;
		#else
			//Disbale Wake up on the sleep pin
			_ARM_REG8(N8LW, M, LOW_POWER) &=  ~_ARM_N8LW_REGM_LOW_POWER_ENABLE;
		#endif
	}
	#endif
	
	//back AT
	err = this->_BackAt();
	if(err != ARM_ERR_NONE)
		return err;
	
	//Send the new value of registers to arm
	return this->UpdateConfig();
}

armError_t Arm::Info(armType_t* armType, uint8_t* rev, uint64_t* sn, uint16_t* rfFreq, uint8_t* rfPower)
{	
	armError_t err = ARM_ERR_NONE;
	armType_t _armType = ARM_TYPE_NONE;
	
	uint16_t _rfFreq = -1;
	uint8_t _rfPower = -1;
		
	//Get type, rev and sn from 'ATV' commend
	if((this->_type==ARM_TYPE_NONE) || rev || sn)
	{
		uint8_t buf[128];
		int nread;
	
		//Go to AT commend
		err = this->_GoAt();
		if(err != ARM_ERR_NONE)
			return err;
			
		//Send 'ATV'
		nread = this->_WriteRead("ATV\r", 4, buf, sizeof buf, _ARM_TIME_TIMEOUT);
		if(nread < 0)
			return ARM_ERR_PORT_WRITE_READ;
		
		//Quit AT commend
		err = this->_BackAt();
		if(err != ARM_ERR_NONE)
			return err;

		//If Lora ?
		if(memmem(buf, nread, "LoRa", 4))
		{
			_armType = ARM_TYPE_N8_LW;
			_rfFreq = 868;
			_rfPower = _ARM_N8LW_MAX_POWER;
		}
		else
		{
			//Is 868Mhz ?
			if(memmem(buf, nread, "868MHZ", 6))
				_rfFreq = 868;
				
			//Is LP?
			if(memmem(buf, nread, "14DBM", 5))
			{
				_rfPower = _ARM_N8LPLD_LP_MAX_POWER;
				_armType = ARM_TYPE_N8_LP;
			}
			else // or LD ?
			{
				_rfPower = _ARM_N8LPLD_LD_MAX_POWER;
				_armType = ARM_TYPE_N8_LD;
			}
		}
		
		//Get ARM firmware revision
		if(rev)
		{
			size_t i=0;
			uint8_t* ptrstr = NULL;
				
			#ifdef ARM_WITH_N8_LPLD
			if(_armType&(ARM_TYPE_N8_LP|ARM_TYPE_N8_LD))
			{
				ptrstr = (uint8_t*)memmem(buf, nread, "REV. ", 5);
				ptrstr += 5;
			}
			#endif
			
			#ifdef ARM_WITH_N8_LW
			if(_armType&(ARM_TYPE_N8_LW))
			{
				ptrstr = (uint8_t*)memmem(buf, nread, "Rev:", 4);
				ptrstr += 4;
			}
			#endif
			
			//Copy string rev
			if(ptrstr)
			{
				while(!(ptrstr[i] == ' ' ||
						ptrstr[i] == '\n'||
						ptrstr[i] == '\0'))
				{
					rev[i] = ptrstr[i];
					i++;
				}
				rev[i] = '\0';
			}
		}
		
		//Get ARM serial number
		if(sn)
		{
			uint8_t* ptrstr = NULL;
				
			#ifdef ARM_WITH_N8_LPLD
			if(_armType&(ARM_TYPE_N8_LP|ARM_TYPE_N8_LD))
			{
				ptrstr = (uint8_t*)memmem(buf, nread, "S/N: ", 5);
				ptrstr += 5;
			}
			#endif
			
			#ifdef ARM_WITH_N8_LW
			if(_armType&(ARM_TYPE_N8_LW))
			{
				ptrstr = (uint8_t*)memmem(buf, nread, "S/N:", 4);
				ptrstr += 4;
			}
			#endif
			
			//Convert serial number string to uint
			*sn = this->_StrToUint(ptrstr, _ARM_BASE_HEX);
		}
	}
	else
	{
		//Get type from ARM type
		_armType = this->_type;
		
		//Get frequency from ARM type
		if(_armType&(ARM_TYPE_N8_LP|ARM_TYPE_N8_LD|ARM_TYPE_N8_LW))
			_rfFreq = 868;
			
		//Get power from ARM type
		if(_armType&(ARM_TYPE_N8_LP|ARM_TYPE_N8_LW))
			_rfPower = _ARM_N8LPLD_LP_MAX_POWER;
		else if(_armType&(ARM_TYPE_N8_LD))
			_rfPower = _ARM_N8LPLD_LD_MAX_POWER;
	}
	
	//Get type
	if(armType)
		*armType = _armType;
	
	//Get frequency
	if(rfFreq)
		*rfFreq = _rfFreq;
	
	//Get power
	if(rfPower)
		*rfPower = _rfPower;

	return err;
}

armError_t Arm::SetMode(armMode_t mode)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP1(N8_LP)
	{
		if(mode == ARM_MODE_FSK)
		{
			_ARM_REG8(N8LPLD, H, APPLICATION1) = _ARM_N8LPLD_REGH_APPLICATION1_UART_RF;
			return ARM_ERR_NONE;
		}
		
		if(mode == ARM_MODE_SFX)
		{
			_ARM_REG8(N8LPLD, H, APPLICATION1) = _ARM_N8LPLD_REGH_APPLICATION1_UART_SFX;
			return ARM_ERR_NONE;
		}
	}
	
	_ARM_IMP1(N8_LD)
	{
		if(mode == ARM_MODE_FSK)
		{
			_ARM_REG8(N8LPLD, H, APPLICATION1) = _ARM_N8LPLD_REGH_APPLICATION1_UART_RF;
			return ARM_ERR_NONE;
		}
	}
	#endif
	
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		if(mode == ARM_MODE_LORAWAN)
			return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

armMode_t Arm::GetMode()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		if(_ARM_REG8(N8LPLD, H, APPLICATION1) == _ARM_N8LPLD_REGH_APPLICATION1_UART_RF)
			return ARM_MODE_FSK;
		if(_ARM_REG8(N8LPLD, H, APPLICATION1) == _ARM_N8LPLD_REGH_APPLICATION1_UART_SFX)
			return ARM_MODE_SFX;
	}
	#endif
	
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		return ARM_MODE_LORAWAN;
	}
	#endif
	
	return ARM_MODE_FSK;
}

armError_t Arm::SfxEnableDownlink(bool enable)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP1(N8_LP)
	{
		if(	(_ARM_REG8(N8LPLD, H, APPLICATION1) != _ARM_N8LPLD_REGH_APPLICATION1_UART_SFX) &&
			(_ARM_REG8(N8LPLD, H, APPLICATION1) != _ARM_N8LPLD_REGH_APPLICATION1_UART_SFXB))
			return ARM_ERR_NO_SUPPORTED;
			
		if(enable)
			_ARM_REG8(N8LPLD, H, APPLICATION1) = _ARM_N8LPLD_REGH_APPLICATION1_UART_SFXB;
		else
			_ARM_REG8(N8LPLD, H, APPLICATION1) = _ARM_N8LPLD_REGH_APPLICATION1_UART_SFX;
			
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

bool Arm::SfxIsEnableDownlink()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP1(N8_LP)
	{
		return (_ARM_REG8(N8LPLD, H, APPLICATION1)==_ARM_N8LPLD_REGH_APPLICATION1_UART_SFXB)?true:false;
	}
	#endif
	
	return false;
}

int8_t Arm::FskMaxPower(uint16_t radioChannel, armBaudrate_t radioBaud)
{
	int a = 0;
	int b = 0;
	int8_t maxPower = 14;
		
	if(radioBaud == ARM_BAUDRATE_NONE)
		return -1;
		
	//Set main coeff
	if(radioBaud <= ARM_BAUDRATE_4800)
	{
		a = 0;
		b = 1;
	}
	else if(radioBaud == ARM_BAUDRATE_9600)
	{
		a = 0;
		b = 2;
	}
	else if(radioBaud == ARM_BAUDRATE_19200)
	{
		a = -1;
		b = 3;
		
		if(	(radioChannel==1) 	||
			(radioChannel==511) ||
			(radioChannel==533))
			maxPower = -1;
	}
	else if(radioBaud == ARM_BAUDRATE_38400)
	{
		a = 0;
		b = 4;
	}
	else if(radioBaud == ARM_BAUDRATE_57600)
	{
		a = 1;
		b = 6;
		
		if(radioChannel==509)
			maxPower = -1;
	}
	else if(radioBaud == ARM_BAUDRATE_115200)
	{
		a = 8;
		b = 16;
		
		if(radioChannel==556)
			maxPower = -1;
	}

	if((radioChannel>=_ARM_MIN_CHANNEL) && (radioChannel<512))
	{
	}
	else if((radioChannel>512) && (radioChannel<532))
	{
		//What is the max power available for channel?
		if((radioChannel>=517) && (radioChannel<=527))
			maxPower = 27;
		else if((radioChannel>=515) && (radioChannel<=529))
			maxPower = 23;
		else
			maxPower = 21;
		
		if(radioBaud == ARM_BAUDRATE_19200)
		{
			a = 0;
			b = 3;
			
			if(	(radioChannel==513) ||
				(radioChannel==531))
			maxPower = -1;
		}
		else if(radioBaud == ARM_BAUDRATE_38400)
		{
			a = 0;
			b = 2;
			
			if(	(radioChannel==514) ||
				(radioChannel==530))
			maxPower = -1;
		}
		else if(radioBaud == ARM_BAUDRATE_57600)
		{
			a = -2;
			b = 5;
		}
		else if(radioBaud == ARM_BAUDRATE_115200)
		{
			a = 6;
			b = 16;
		}
	}
	else if((radioChannel>532) && (radioChannel<=_ARM_MAX_CHANNEL))
	{
		a -= 4;
	}
	else
		return -1;
	
	if(!((radioChannel+a)%b))
		return maxPower;
	
	return -1;
}

armError_t Arm::FskSetRadio(uint16_t channel, armBaudrate_t baud, int8_t power)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		int8_t maxPower;
		int8_t armMaxPower = this->_type&ARM_TYPE_N8_LP?_ARM_N8LPLD_LP_MAX_POWER:_ARM_N8LPLD_LD_MAX_POWER;

		//The parameter is out of range?
		if(	(channel < _ARM_MIN_CHANNEL) || (channel > _ARM_MAX_CHANNEL) ||
			((power != ARM_FSK_POWER_AUTO) && ((power > armMaxPower) || (power < _ARM_MIN_RADIO_POWER))))
			return ARM_ERR_PARAM_OUT_OF_RANGE;
		
		//Check if the new parameters is possible
		maxPower = this->FskMaxPower(channel, baud);
		if(	(maxPower == -1) ||
			(power > maxPower))
			return ARM_ERR_PARAM_INCOMPATIBLE;
		
		//Set baudrate
		switch(baud)
		{
			case ARM_BAUDRATE_1200:
				_ARM_REG8(N8LPLD, H, RADIO_BAUDRATE) = _ARM_N8LPLD_REGH_RADIO_BAUDRATE_1200;
			break;
			
			case ARM_BAUDRATE_2400:	                  
				_ARM_REG8(N8LPLD, H, RADIO_BAUDRATE) = _ARM_N8LPLD_REGH_RADIO_BAUDRATE_2400;
			break;
			
			case ARM_BAUDRATE_4800:	                  
				_ARM_REG8(N8LPLD, H, RADIO_BAUDRATE) = _ARM_N8LPLD_REGH_RADIO_BAUDRATE_4800;
			break;
			
			case ARM_BAUDRATE_9600:	                  
				_ARM_REG8(N8LPLD, H, RADIO_BAUDRATE) = _ARM_N8LPLD_REGH_RADIO_BAUDRATE_9600;
			break;
			
			case ARM_BAUDRATE_19200:	                  
				_ARM_REG8(N8LPLD, H, RADIO_BAUDRATE) = _ARM_N8LPLD_REGH_RADIO_BAUDRATE_19200;
			break;
			
			case ARM_BAUDRATE_38400:	                  
				_ARM_REG8(N8LPLD, H, RADIO_BAUDRATE) = _ARM_N8LPLD_REGH_RADIO_BAUDRATE_38400;
			break;
			
			case ARM_BAUDRATE_57600:	                  
				_ARM_REG8(N8LPLD, H, RADIO_BAUDRATE) = _ARM_N8LPLD_REGH_RADIO_BAUDRATE_57600;
			break;
			
			case ARM_BAUDRATE_115200:	              
				_ARM_REG8(N8LPLD, H, RADIO_BAUDRATE) = _ARM_N8LPLD_REGH_RADIO_BAUDRATE_115200;
			break;
			
			default:
				return ARM_ERR_PARAM_OUT_OF_RANGE;
			break;
		}
		
		//Set channel if LBT&AFA mode is disable
		//if(LBT&AFA)
			_ARM_REG16_SET(N8LPLD, H, CHANNEL1, channel);
		
		//Power is adjusted ?
		if((power == ARM_FSK_POWER_AUTO))
			_ARM_REG8(N8LPLD, H, POWER) = _ARM_N8LPLD_REGH_POWER_LIMIT;
		else
		{
			_ARM_REG8(N8LPLD, H, POWER) = _ARM_N8LPLD_REGH_POWER_USER_GAIN;
			_ARM_REG8(N8LPLD, H, USER_GAIN) = power;
		}
		
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

void Arm::FskGetRadio(uint16_t* channel, armBaudrate_t* baud, int8_t* power)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		//Get channel
		if(channel)
		{
			_ARM_REG16_GET(N8LPLD, H, CHANNEL1, *channel);
		}
		
		//Get baudrate
		if(baud)
		{
			switch(_ARM_REG8(N8LPLD, H, RADIO_BAUDRATE))
			{
				case _ARM_N8LPLD_REGH_RADIO_BAUDRATE_1200:
					*baud = (armBaudrate_t)1200;
				break;
				
				case _ARM_N8LPLD_REGH_RADIO_BAUDRATE_2400:	                  
					*baud = (armBaudrate_t)2400;
				break;
				
				case _ARM_N8LPLD_REGH_RADIO_BAUDRATE_4800:	                  
					*baud = (armBaudrate_t)4800;
				break;
				
				case _ARM_N8LPLD_REGH_RADIO_BAUDRATE_9600:	                  
					*baud = (armBaudrate_t)9600;
				break;
				
				case _ARM_N8LPLD_REGH_RADIO_BAUDRATE_19200:	                  
					*baud = (armBaudrate_t)19200;
				break;
				
				case _ARM_N8LPLD_REGH_RADIO_BAUDRATE_38400:	                  
					*baud = (armBaudrate_t)38400;
				break;
				
				case _ARM_N8LPLD_REGH_RADIO_BAUDRATE_57600:	                  
					*baud = (armBaudrate_t)57600;
				break;
				
				case _ARM_N8LPLD_REGH_RADIO_BAUDRATE_115200:	              
					*baud = (armBaudrate_t)115200;
				break;
				
				default:
					*baud = ARM_BAUDRATE_NONE;
				break;
			}
		}
		
		//Get power
		if(power)
		{
			//Power is auto adjusted ?
			if(_ARM_REG8(N8LPLD, H, POWER) == _ARM_N8LPLD_REGH_POWER_LIMIT)
				*power = ARM_FSK_POWER_AUTO;
			else
				*power = _ARM_REG8(N8LPLD, H, USER_GAIN);
		}
	}
	#endif
}

armError_t Arm::FskSetRemoteAdd(uint8_t add)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		//Error if the addressing is not enable.
		if(_ARM_REG8(N8LPLD, H, SETTING2)&_ARM_N8LPLD_REGH_SETTING2_LONG_HEADRE)
			return ARM_ERR_ADDRESSING_NOT_ENABLE;
			
		_ARM_REG8(N8LPLD, H, REMOTE_ADDRESS) = add;
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

uint8_t Arm::FskGetRemoteAdd()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		return _ARM_REG8(N8LPLD, H, REMOTE_ADDRESS);
	}
	#endif
	
	return 255;
}

armError_t Arm::FskSetLocalAdd(uint8_t add)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		//Error if the addressing is not enable.
		if(_ARM_REG8(N8LPLD, H, SETTING2)&_ARM_N8LPLD_REGH_SETTING2_LONG_HEADRE)
			return ARM_ERR_ADDRESSING_NOT_ENABLE;
		
		_ARM_REG8(N8LPLD, H, LOCAL_ADDRESS) = add;
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

uint8_t Arm::FskGetLocalAdd()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		return _ARM_REG8(N8LPLD, H, LOCAL_ADDRESS);
	}
	#endif
	
	return 0;
}

void Arm::FskEnableAddressing(bool enable)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		if(enable) //Enable long header
			_ARM_REG8(N8LPLD, H, SETTING2) |= _ARM_N8LPLD_REGH_SETTING2_LONG_HEADRE;
		else //Disable long header
			_ARM_REG8(N8LPLD, H, SETTING2) &= ~_ARM_N8LPLD_REGH_SETTING2_LONG_HEADRE;
	}
	#endif
}

bool Arm::FskIsEnableAddressing()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		return (_ARM_REG8(N8LPLD, H, SETTING2)&_ARM_N8LPLD_REGH_SETTING2_LONG_HEADRE)?true:false;
	}
	#endif
	
	return false;
}

void Arm::FskEnableCrc(bool enable)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		if(enable)
		{
			//Disable infinity mode.
			_ARM_REG8(N8LPLD, H, SETTING1) &= ~_ARM_N8LPLD_REGH_SETTING1_INFINITY_MODE;
			_ARM_REG8(N8LPLD, H, SETTING1) |= _ARM_N8LPLD_REGH_SETTING1_PACKET_MODE;

			//Enable crc
			_ARM_REG8(N8LPLD, H, SETTING2) |= _ARM_N8LPLD_REGH_SETTING2_CRC;
		}
		else //Disable crc
			_ARM_REG8(N8LPLD, H, SETTING2) &= ~_ARM_N8LPLD_REGH_SETTING2_CRC;
	}
	#endif
}

bool Arm::FskIsEnableCrc()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		return (_ARM_REG8(N8LPLD, H, SETTING2)&_ARM_N8LPLD_REGH_SETTING2_CRC)?true:false;
	}
	#endif
	
	return false;
}

armError_t Arm::FskEnableInfinityMode(bool enable)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		if(enable)
		{
			//WOR is enable? 
			if(_ARM_REG8(N8LPLD, H, WAKE_UP_RF)&_ARM_N8LPLD_REGH_WAKE_UP_RF_RF)
				return ARM_ERR_WOR_ENABLE;
				
			//Disable crc.
			_ARM_REG8(N8LPLD, H, SETTING2) &= ~_ARM_N8LPLD_REGH_SETTING2_CRC;

			//Disable packet mode and enable infinity mode
			_ARM_REG8(N8LPLD, H, SETTING1) &= ~_ARM_N8LPLD_REGH_SETTING1_PACKET_MODE;
			_ARM_REG8(N8LPLD, H, SETTING1) |= _ARM_N8LPLD_REGH_SETTING1_INFINITY_MODE;
			_ARM_REG8(N8LPLD, H, BRIDGE_SETTING) &= ~(_ARM_N8LPLD_REGH_BRIDGE_SETTING_TXRF|_ARM_N8LPLD_REGH_BRIDGE_SETTING_RXRF);
		}
		else //Disable infinity mode and enable packet mode
		{
			_ARM_REG8(N8LPLD, H, SETTING1) &= ~_ARM_N8LPLD_REGH_SETTING1_INFINITY_MODE;
			_ARM_REG8(N8LPLD, H, SETTING1) |= _ARM_N8LPLD_REGH_SETTING1_PACKET_MODE;
			_ARM_REG8(N8LPLD, H, BRIDGE_SETTING) |= _ARM_N8LPLD_REGH_BRIDGE_SETTING_TXRF|_ARM_N8LPLD_REGH_BRIDGE_SETTING_RXRF;
		}
		
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

bool Arm::FskIsEnableInfinityMode()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		return (_ARM_REG8(N8LPLD, H, SETTING1)&_ARM_N8LPLD_REGH_SETTING1_INFINITY_MODE)?true:false;
	}
	#endif
	
	return false;
}

void Arm::FskEnableWhitening(bool enable)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		if(enable)//Enable whitening
			_ARM_REG8(N8LPLD, H, SETTING2) |= _ARM_N8LPLD_REGH_SETTING2_WHITENING;
		else //Disable whitening
			_ARM_REG8(N8LPLD, H, SETTING2) &= ~_ARM_N8LPLD_REGH_SETTING2_WHITENING;
	}
	#endif
}

bool Arm::FskIsEnableWhitening()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		return (_ARM_REG8(N8LPLD, H, SETTING2)&_ARM_N8LPLD_REGH_SETTING2_WHITENING)?true:false;
	}
	#endif
	
	return false;
}

armError_t Arm::SetSerial(armPortBaudrate_t baud, armPortDatabits_t databits, armPortParity_t parity, armPortStopbit_t stopbit)
{	
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		//Check if baud is compatible with wake up on uart if enable.
		if(_ARM_REG8(N8LPLD, H, WAKE_UP_PWR)&_ARM_N8LPLD_REGH_WAKE_UP_PWR_UART &&
			baud > ARMPORT_BAUDRATE_38400)
			return ARM_ERR_PARAM_OUT_OF_RANGE;
		
		//Set baudrate
		switch(baud)
		{
			case ARMPORT_BAUDRATE_1200:
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_1200;
			break;
			
			case ARMPORT_BAUDRATE_2400:	                  
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_2400;
			break;
			
			case ARMPORT_BAUDRATE_4800:	                  
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_4800;
			break;
			
			case ARMPORT_BAUDRATE_9600:	                  
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_9600;
			break;
			
			case ARMPORT_BAUDRATE_19200:	                  
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_19200;
			break;
			
			case ARMPORT_BAUDRATE_38400:	                  
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_38400;
			break;
			
			case ARMPORT_BAUDRATE_57600:	                  
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_57600;
			break;
			
			case ARMPORT_BAUDRATE_115200:	              
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_115200;
			break;
			
			case ARMPORT_BAUDRATE_230400:	              
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_230400;
			break;
			
			default:
				return ARM_ERR_PARAM_OUT_OF_RANGE;
			break;
		}
		
		//Set databits
		_ARM_REG8(N8LPLD, H, SERIAL_DATABITS) = databits;
		
		//Set databits
		switch(parity)
		{
			case ARMPORT_PARITY_ODD:
				_ARM_REG8(N8LPLD, H, SERIAL_PARITY) = _ARM_N8LPLD_REGH_SERIAL_PARITY_ODD;
			break;
			
			case ARMPORT_PARITY_EVEN:
				_ARM_REG8(N8LPLD, H, SERIAL_PARITY) = _ARM_N8LPLD_REGH_SERIAL_PARITY_EVEN;
			break;
			
			case ARMPORT_PARITY_NO:
			default:
				_ARM_REG8(N8LPLD, H, SERIAL_PARITY) = _ARM_N8LPLD_REGH_SERIAL_PARITY_NO;
			break;
		}
		
		//Set databits
		_ARM_REG8(N8LPLD, H, SERIAL_STOPBIT) = stopbit;

		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

void Arm::GetSerial(armPortBaudrate_t* baud, armPortDatabits_t* databits, armPortParity_t* parity, armPortStopbit_t* stopbit)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		//Get baudrate
		if(baud)
		{
			switch(_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE))
			{
				case _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_1200:
					*baud = (armPortBaudrate_t)1200;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_2400:	                  
					*baud = (armPortBaudrate_t)2400;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_4800:	                  
					*baud = (armPortBaudrate_t)4800;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_9600:	                  
					*baud = (armPortBaudrate_t)9600;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_19200:	                  
					*baud = (armPortBaudrate_t)19200;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_38400:	                  
					*baud = (armPortBaudrate_t)38400;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_57600:	                  
					*baud = (armPortBaudrate_t)57600;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_115200:	              
					*baud = (armPortBaudrate_t)115200;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_230400:	              
					*baud = (armPortBaudrate_t)230400;
				break;
				
				default:
					*baud = ARMPORT_BAUDRATE_NONE;
				break;
			}
		}
		
		//Get databits
		if(databits)
			*databits = (armPortDatabits_t)_ARM_REG8(N8LPLD, H, SERIAL_DATABITS);
		
		
		//Get parity
		if(parity)
		{
			switch(_ARM_REG8(N8LPLD, H, SERIAL_PARITY))
			{
				case _ARM_N8LPLD_REGH_SERIAL_PARITY_ODD:	              
					*parity = ARMPORT_PARITY_ODD;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_PARITY_EVEN:	              
					*parity = ARMPORT_PARITY_EVEN;
				break;
				
				case _ARM_N8LPLD_REGH_SERIAL_PARITY_NO:
				default:
					*parity = ARMPORT_PARITY_NO;
				break;
			}
		}
		
		//Get stopbit
		if(stopbit)
			*stopbit = (armPortStopbit_t)_ARM_REG8(N8LPLD, H, SERIAL_STOPBIT);
	}
	#endif
}

armError_t Arm::FskSetWorMode(armFskWor_t mode, uint16_t periodTime, uint16_t postTime, int8_t rssiLevel, bool filterLongPreamble)
{	
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		//Disable WOR mode
		_ARM_REG8(N8LPLD, H, WAKE_UP_RF) &= ~_ARM_N8LPLD_REGH_WAKE_UP_RF_RF;
		#ifndef ARMPORT_WITH_nSLEEP
			_ARM_REG8(N8LPLD, H, WAKE_UP_PWR) &= ~_ARM_N8LPLD_REGH_WAKE_UP_PWR_UART;
		#endif
		_ARM_REG8(N8LPLD, H, SETTING1) &= ~_ARM_N8LPLD_REGH_SETTING1_LONG_PREAMBLE;
		
		//Return if disable mode.
		if(mode == ARM_FSK_WOR_DISABLE)
			return ARM_ERR_NONE;

		//periodTime out of rang?
		if(periodTime>_ARM_MAX_LONG_PREAMBLE_TIME)
			return ARM_ERR_PARAM_OUT_OF_RANGE;
		
		//postTime out of rang?
		if(postTime>_ARM_MAX_POST_TIME)
			return ARM_ERR_PARAM_OUT_OF_RANGE;
			
		//Set period time (same registers than long preamble)
		_ARM_REG16_SET(N8LPLD, H, LONG_PREAMBLE, periodTime);
		
		//Set post time
		_ARM_REG8(N8LPLD, H, POST_TIME) = postTime/10;
		
		//Enable long preamble?
		if(mode == ARM_FSK_WOR_LP)
		{
			_ARM_REG8(N8LPLD, H, SETTING1) |= _ARM_N8LPLD_REGH_SETTING1_LONG_PREAMBLE;
			return ARM_ERR_NONE;
		}

		//Enable wake up on radio
		_ARM_REG8(N8LPLD, H, WAKE_UP_RF) |= _ARM_N8LPLD_REGH_WAKE_UP_RF_RF;
		
		#ifndef ARMPORT_WITH_nSLEEP
		//Change uart baudrate if necessary
		if(_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) > _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_38400)
			_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_38400;
		//Enable wake up on uart
		_ARM_REG8(N8LPLD, H, WAKE_UP_PWR) |=  _ARM_N8LPLD_REGH_WAKE_UP_PWR_UART;
		#endif
		
		//Set WOR in CS 'Carrier Sense'?
		if(mode == ARM_FSK_WOR_CS)
		{
			_ARM_REG8(N8LPLD, H, SETTING1) |= _ARM_N8LPLD_REGH_SETTING1_WOR_CS;
			
			//Set rssi level if WOR in CS
			_ARM_REG8(N8LPLD, H, RSSI_LEVEL) = rssiLevel;
		}
		//Set WOR in PQT 'Preamble Quality Threshold'?
		else
		{
			_ARM_REG8(N8LPLD, H, SETTING1) &= ~_ARM_N8LPLD_REGH_SETTING1_WOR_CS;
		}
		
		//Enable/disable filter in long preamble
		if(filterLongPreamble)
			_ARM_REG8(N8LPLD, H, SETTING1) |= _ARM_N8LPLD_REGH_SETTING1_FILTER_LONG_PREAMBLE;
		else
			_ARM_REG8(N8LPLD, H, SETTING1) &= ~_ARM_N8LPLD_REGH_SETTING1_FILTER_LONG_PREAMBLE;
		
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

void Arm::FskGetWorMode(armFskWor_t* mode, uint16_t* periodTime, uint16_t* postTime, int8_t* rssiLevel, bool* filterLongPreamble)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		//Get WOR mode
		if(mode)
		{
			//WOR is enable? 
			if(_ARM_REG8(N8LPLD, H, WAKE_UP_RF)&_ARM_N8LPLD_REGH_WAKE_UP_RF_RF)
			{
				//WOR in CS 'Carrier Sense'?
				if(_ARM_REG8(N8LPLD, H, SETTING1)&_ARM_N8LPLD_REGH_SETTING1_WOR_CS)
					*mode = ARM_FSK_WOR_CS;
				else//WOR in PQT 'Preamble Quality Threshold'?
					*mode = ARM_FSK_WOR_PQT;
			}
			//long preamble is enable? 
			else if(_ARM_REG8(N8LPLD, H, SETTING1)&_ARM_N8LPLD_REGH_SETTING1_LONG_PREAMBLE)
				*mode = ARM_FSK_WOR_LP;
			else //WOR is disable?
				*mode = ARM_FSK_WOR_DISABLE;
		}
		
		//Get post time
		if(postTime)
			*postTime = _ARM_REG8(N8LPLD, H, POST_TIME)*10;
		
		//Get period time
		if(periodTime)
		{
			_ARM_REG16_GET(N8LPLD, H, LONG_PREAMBLE, *periodTime);
		}
		
		//Get rssi level
		if(rssiLevel)
			*rssiLevel = _ARM_REG8(N8LPLD, H, RSSI_LEVEL);
		
		//Get filter
		if(filterLongPreamble)
			*filterLongPreamble = (_ARM_REG8(N8LPLD, H, SETTING1)&_ARM_N8LPLD_REGH_SETTING1_FILTER_LONG_PREAMBLE)?true:false;
	}
	#endif
}

armError_t Arm::EnableWakeUpUart(bool enable)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		//Disable?
		if(enable == false)
		{
			#ifndef ARMPORT_WITH_nSLEEP
			//WOR is enable? 
			if(_ARM_REG8(N8LPLD, H, WAKE_UP_RF)&_ARM_N8LPLD_REGH_WAKE_UP_RF_RF)
				return ARM_ERR_WOR_ENABLE;
			#endif
			
			_ARM_REG8(N8LPLD, H, WAKE_UP_PWR) &=  ~_ARM_N8LPLD_REGH_WAKE_UP_PWR_UART;
		}
		else //Enable?
		{
			//Change uart baudrate if necessary
			if(_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) > _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_38400)
				_ARM_REG8(N8LPLD, H, SERIAL_BAUDRATE) = _ARM_N8LPLD_REGH_SERIAL_BAUDRATE_38400;
			
			_ARM_REG8(N8LPLD, H, WAKE_UP_PWR) |=  _ARM_N8LPLD_REGH_WAKE_UP_PWR_UART;
		}
		
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

bool Arm::IsEnableWakeUpUart()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		return (_ARM_REG8(N8LPLD, H, WAKE_UP_PWR)&_ARM_N8LPLD_REGH_WAKE_UP_PWR_UART)?true:false;
	}
	#endif
	
	return false;
}

#ifdef ARMPORT_WITH_nSLEEP
void Arm::Sleep(bool sleep)
{
	this->_port.GpioSet(ARMPORT_PIN_nSLEEP, !sleep);
}

#endif

armError_t Arm::FskSetLbtAfaMode(armFskLbtAfa_t mode, int8_t rssiLevel, uint16_t nSamples, uint16_t channel2)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		armBaudrate_t baud;
		int8_t power;
		int8_t maxPower;
		
		//Disable LBT&AFA mode?
		if(mode == ARM_FSK_LBTAFA_DISABLE)
		{
			_ARM_REG8(N8LPLD, H, SETTING1) &= (_ARM_N8LPLD_REGH_SETTING1_LBT|_ARM_N8LPLD_REGH_SETTING1_AFA);
			return ARM_ERR_NONE;
		}
		
		//The parameter is out of range?
		if(	(channel2 < _ARM_MIN_CHANNEL) || (channel2 > _ARM_MAX_CHANNEL))
			return ARM_ERR_PARAM_OUT_OF_RANGE;
		
		//Check if the new parameters is possible
		this->FskGetRadio(NULL, &baud, &power);
		maxPower = this->FskMaxPower(channel2, baud);
		if(	(maxPower == -1) ||
			(power > maxPower))
			return ARM_ERR_PARAM_INCOMPATIBLE;
		
		//Enable LBT mode
		_ARM_REG8(N8LPLD, H, SETTING1) |= _ARM_N8LPLD_REGH_SETTING1_LBT;
		
		//Set rssi level
		_ARM_REG8(N8LPLD, H, RSSI_LEVEL) = rssiLevel;
		
		//Set nSamples
		_ARM_REG16_SET(N8LPLD, H, NSAMPLE, nSamples);
		
		//Enable AFA mode?
		if(mode == ARM_FSK_LBTAFA_LBTAFA)
		{
			//Set AFA mode
			_ARM_REG8(N8LPLD, H, SETTING1) |= _ARM_N8LPLD_REGH_SETTING1_AFA;
			
			//Set channel2
			_ARM_REG16_SET(N8LPLD, H, CHANNEL2, channel2);
		}
		
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

void Arm::FskGetLbtAfaMode(armFskLbtAfa_t* mode, int8_t* rssiLevel, uint16_t* nSamples, uint16_t* channel2)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		//Get LBT&AFA mode
		if(mode)
		{
			//LBT is enable?
			if(_ARM_REG8(N8LPLD, H, SETTING1)&_ARM_N8LPLD_REGH_SETTING1_LBT)
			{
				//AFA is enable?
				if(_ARM_REG8(N8LPLD, H, SETTING1)&_ARM_N8LPLD_REGH_SETTING1_AFA)
					*mode = ARM_FSK_LBTAFA_LBTAFA;
				else
					*mode = ARM_FSK_LBTAFA_LBT;
			}
			else
				*mode = ARM_FSK_LBTAFA_DISABLE;
		}
		
		//Get rssi level
		if(rssiLevel)
			*rssiLevel = _ARM_REG8(N8LPLD, H, RSSI_LEVEL);
		
		//Get nSamples
		if(nSamples)
		{
			_ARM_REG16_GET(N8LPLD, H, NSAMPLE, *nSamples);
		}
		
		//Get channel 2
		if(channel2)
		{
			_ARM_REG16_GET(N8LPLD, H, CHANNEL2, *channel2);
		}
	}
	#endif
}

void Arm::SetLed(armLed_t led)
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		_ARM_REG8(N8LPLD, H, ON_BOARD) &= ~(_ARM_N8LPLD_REGH_ON_BOARD_TXRX_ON|_ARM_N8LPLD_REGH_ON_BOARD_TXRX_OFF);
		
		switch(led)
		{
			case ARM_LED_OFF:
			break;
			
			case ARM_LED_OFF_RF:
				_ARM_REG8(N8LPLD, H, ON_BOARD) |= _ARM_N8LPLD_REGH_ON_BOARD_TXRX_OFF;
			break;
			
			case ARM_LED_ON_RF:
				_ARM_REG8(N8LPLD, H, ON_BOARD) |= _ARM_N8LPLD_REGH_ON_BOARD_TXRX_ON;
			break;
		}
	}
	#endif
	
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		_ARM_REG8(N8LW, M, LED) |= 	_ARM_N8LW_REGM_LED_BOOT 	|
									_ARM_N8LW_REGM_LED_WAKEUP 	|
									_ARM_N8LW_REGM_LED_RADIO_TX |
									_ARM_N8LW_REGM_LED_RADIO_RX |
									_ARM_N8LW_REGM_LED_DEFAULT_STATE;
											
		switch(led)
		{
			case ARM_LED_OFF:
				_ARM_REG8(N8LW, M, LED) &=~(_ARM_N8LW_REGM_LED_BOOT 	|
											_ARM_N8LW_REGM_LED_WAKEUP 	|
											_ARM_N8LW_REGM_LED_RADIO_TX |
											_ARM_N8LW_REGM_LED_RADIO_RX);
			break;
			
			case ARM_LED_OFF_RF:
				_ARM_REG8(N8LW, M, LED) &= ~_ARM_N8LW_REGM_LED_DEFAULT_STATE;
			break;
			
			case ARM_LED_ON_RF:
			break;
		}
	}
	#endif
}

armLed_t Arm::GetLed()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		if(_ARM_REG8(N8LPLD, H, ON_BOARD)&_ARM_N8LPLD_REGH_ON_BOARD_TXRX_ON)
			return ARM_LED_ON_RF;
			
		if(_ARM_REG8(N8LPLD, H, ON_BOARD)&_ARM_N8LPLD_REGH_ON_BOARD_TXRX_OFF)
			return ARM_LED_OFF_RF;
	}
	#endif
	
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		if(!(_ARM_REG8(N8LW, M, LED)&_ARM_N8LW_REGM_LED_DEFAULT_STATE))
			return ARM_LED_OFF_RF;
		
		if(_ARM_REG8(N8LW, M, LED)&(_ARM_N8LW_REGM_LED_BOOT 	|
									_ARM_N8LW_REGM_LED_WAKEUP 	|
									_ARM_N8LW_REGM_LED_RADIO_TX |
									_ARM_N8LW_REGM_LED_RADIO_RX))
			return ARM_LED_ON_RF;
	}
	#endif
	
	return ARM_LED_OFF;
}

armError_t Arm::LwSetRadio(uint8_t txChannel, uint8_t power, uint8_t txSf, uint8_t rx2Sf, uint8_t rx2Channel)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		//Check if txChannel is out of range
		if(txChannel > 9)
			return ARM_ERR_PARAM_OUT_OF_RANGE;
			
		//Check if txSf is out of range
		if((txSf != 0) && ((txSf < 7) || (txSf > 12)))
			return ARM_ERR_PARAM_OUT_OF_RANGE;
			
		//Check if txSf is out of range
		if((rx2Sf != 0) && ((rx2Sf < 7) || (rx2Sf > 12)))
			return ARM_ERR_PARAM_OUT_OF_RANGE;
			
		//Check if rx2Channel is out of range
		if(rx2Channel > 9)
			return ARM_ERR_PARAM_OUT_OF_RANGE;
			
		//Set power?
		if(power != 0)
		{
			uint8_t regPower = _ARM_REG8(N8LW, O, POWER) &= ~0x07;
			
			//Set parameter
			switch(power)
			{
				case 2:
					regPower |= _ARM_N8LW_REGO_POWER_2;
				break;
				
				case 5:
					regPower |= _ARM_N8LW_REGO_POWER_5;
				break;
				
				case 8:
					regPower |= _ARM_N8LW_REGO_POWER_8;
				break;
				
				case 11:
					regPower |= _ARM_N8LW_REGO_POWER_11;
				break;
				
				case 14:
					regPower |= _ARM_N8LW_REGO_POWER_14;
				break;
				
				default:
					return ARM_ERR_PARAM_OUT_OF_RANGE;
				break;
			}
			_ARM_REG8(N8LW, O, POWER) = regPower;
			
			//Disable Tx Adaptive Speed
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_ADAPTIVE_SPEED;
		}

		//Set txChannel?
		if(txChannel != 0)
		{
			//Set parameter
			txChannel -= 1;
			_ARM_REG8(N8LW, O, TXRX2_CHANNEL) &= ~0x0f;
			_ARM_REG8(N8LW, O, TXRX2_CHANNEL) |= txChannel;
			
			//Disable Adaptive Channel
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_ADAPTIVE_CHANNEL;
		}
		
		//Set txSf?
		if(txSf != 0)
		{
			//Set parameter
			_ARM_REG8(N8LW, O, TXRX2_SF) &= ~0x07;
			_ARM_REG8(N8LW, O, TXRX2_SF) |= 12-txSf;
			
			//Disable Tx Adaptive Speed
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_ADAPTIVE_SPEED;
		}
		
		//Set rx2Sf?
		if(rx2Sf != 0)
		{
			//Set parameter
			_ARM_REG8(N8LW, O, TXRX2_SF) &= ~(0x07<<3);
			_ARM_REG8(N8LW, O, TXRX2_SF) |= (12-rx2Sf)<<3;
			
			//Disable rx2 Adaptive
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_ADAPTIVE_RX2;
		}
		
		//Set rx2Channel?
		if(rx2Channel != 0)
		{
			//Set parameter
			rx2Channel -= 1;
			_ARM_REG8(N8LW, O, TXRX2_CHANNEL) &= ~0xf0;
			_ARM_REG8(N8LW, O, TXRX2_CHANNEL) |= rx2Channel<<4;
			
			//Disable rx2 Adaptive
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_ADAPTIVE_RX2;
		}
		
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

void Arm::LwGetRadio(uint8_t* txChannel, uint8_t* power, uint8_t* txSf, uint8_t* rx2Sf, uint8_t* rx2Channel)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{	
		//Get txChannel
		if(txChannel)
		{
			*txChannel = _ARM_REG8(N8LW, O, TXRX2_CHANNEL)&0x0f;
			*txChannel += 1;
		}
		
		//Get power
		if(power)
		{
			switch(_ARM_REG8(N8LW, O, POWER)&0x07)
			{
				case _ARM_N8LW_REGO_POWER_14:
					*power = 14;
				break;
				
				case _ARM_N8LW_REGO_POWER_11:
					*power = 11;
				break;
				
				case _ARM_N8LW_REGO_POWER_8:
					*power = 8;
				break;
				
				case _ARM_N8LW_REGO_POWER_5:
					*power = 5;
				break;
				
				case _ARM_N8LW_REGO_POWER_2:
					*power = 2;
				break;
				
				default:
					*power = 0;
				break;
			}
		}
		
		//Get txSf
		if(txSf)
		{
			*txSf = _ARM_REG8(N8LW, O, TXRX2_SF)&0x07;
			*txSf = 12-(*txSf);
		}
		
		//Get rx2Sf
		if(rx2Sf)
		{
			*rx2Sf = (_ARM_REG8(N8LW, O, TXRX2_SF)>>3)&0x07;
			*rx2Sf = 12-(*rx2Sf);
		}
		
		//Get rx2Channel
		if(rx2Channel)
		{
			*rx2Channel = (_ARM_REG8(N8LW, O, TXRX2_CHANNEL)>>4)&0x0f;
			*rx2Channel += 1;
		}
	}
	#endif
}

armError_t Arm::LwSetConfirmedFrame(int8_t nbFrame)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		//Check if out of range
		if((nbFrame > 15) && (nbFrame < -15))
			return ARM_ERR_PARAM_OUT_OF_RANGE;
		
		//Set the value
		if(ARM_LW_IS_UNCONFIRMED(nbFrame))
			_ARM_REG8(N8LW, O, CONFIRMED_FRAME) = ARM_LW_UNCONFIRMED(nbFrame);
		else
			_ARM_REG8(N8LW, O, CONFIRMED_FRAME) = nbFrame<<4;
			
		return ARM_ERR_NONE;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

int8_t Arm::LwGetConfirmedFrame()
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		if(_ARM_REG8(N8LW, O, CONFIRMED_FRAME)&0x0f) //Is unconfirmed?
			return ARM_LW_UNCONFIRMED(_ARM_REG8(N8LW, O, CONFIRMED_FRAME));
		else //Is confirmed?
			return _ARM_REG8(N8LW, O, CONFIRMED_FRAME)>>4;
	}
	#endif
	
	return 0;
}

void Arm::LwSetPortField(uint8_t port)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		_ARM_REG8(N8LW, O, PORT_FIELD) = port;
	}
	#endif
}

uint8_t Arm::LwGetPortField()
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		return _ARM_REG8(N8LW, O, PORT_FIELD);
	}
	#endif
	
	return 0;
}

void Arm::LwEnableOtaa(bool enable)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		if(enable)
			_ARM_REG8(N8LW, O, CONFIG) |= _ARM_N8LW_REGO_CONFIG_OTAA;
		else
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_OTAA;
	}
	#endif
}

bool Arm::LwIsEnableOtaa()
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		return (_ARM_REG8(N8LW, O, CONFIG)&_ARM_N8LW_REGO_CONFIG_OTAA)?true:false;
	}
	#endif
	
	return false;
}

void Arm::LwEnableRxWindows(bool enable)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		if(enable)
			_ARM_REG8(N8LW, O, CONFIG) |= _ARM_N8LW_REGO_CONFIG_RX_ON;
		else
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_RX_ON;
	}
	#endif
}

bool Arm::LwIsEnableRxWindows()
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		return (_ARM_REG8(N8LW, O, CONFIG)&_ARM_N8LW_REGO_CONFIG_RX_ON)?true:false;
	}
	#endif
	
	return false;
}

void Arm::LwEnableTxAdaptiveSpeed(bool enable)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		if(enable)
			_ARM_REG8(N8LW, O, CONFIG) |= _ARM_N8LW_REGO_CONFIG_ADAPTIVE_SPEED;
		else
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_ADAPTIVE_SPEED;
	}
	#endif
}

bool Arm::LwIsEnableTxAdaptiveSpeed()
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		return (_ARM_REG8(N8LW, O, CONFIG)&_ARM_N8LW_REGO_CONFIG_ADAPTIVE_SPEED)?true:false;
	}
	#endif
	
	return false;
}

void Arm::LwEnableDutyCycle(bool enable)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		if(enable)
			_ARM_REG8(N8LW, O, CONFIG) |= _ARM_N8LW_REGO_CONFIG_DUTY_CYCLE;
		else
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_DUTY_CYCLE;
	}
	#endif
}

bool Arm::LwIsEnableDutyCycle()
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		return (_ARM_REG8(N8LW, O, CONFIG)&_ARM_N8LW_REGO_CONFIG_DUTY_CYCLE)?true:false;
	}
	#endif
	
	return false;
}

void Arm::LwEnableTxAdaptiveChannel(bool enable)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		if(enable)
			_ARM_REG8(N8LW, O, CONFIG) |= _ARM_N8LW_REGO_CONFIG_ADAPTIVE_CHANNEL;
		else
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_ADAPTIVE_CHANNEL;
	}
	#endif
}

bool Arm::LwIsEnableTxAdaptiveChannel()
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		return (_ARM_REG8(N8LW, O, CONFIG)&_ARM_N8LW_REGO_CONFIG_ADAPTIVE_CHANNEL)?true:false;
	}
	#endif
	
	return false;
}

void Arm::LwEnableRx2Adaptive(bool enable)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		if(enable)
			_ARM_REG8(N8LW, O, CONFIG) |= _ARM_N8LW_REGO_CONFIG_ADAPTIVE_RX2;
		else
			_ARM_REG8(N8LW, O, CONFIG) &= ~_ARM_N8LW_REGO_CONFIG_ADAPTIVE_RX2;
	}
	#endif
}

bool Arm::LwIsEnableRx2Adaptive()
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		return (_ARM_REG8(N8LW, O, CONFIG)&_ARM_N8LW_REGO_CONFIG_ADAPTIVE_RX2)?true:false;
	}
	#endif
	
	return false;
}

armError_t Arm::LwIds(uint32_t* devAddr,
									uint64_t* devEui,
									uint64_t* appEui,
									uint128_t* appKey,
									uint128_t* nwkSKey,
									uint128_t* appSKey)
{
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		armError_t err = ARM_ERR_NONE;
		int i;
		
		//Go to AT commend
		err = this->_GoAt();
		if(err != ARM_ERR_NONE)
			return err;
			
		if(devAddr)
		{
			
			for(i=0; i<_ARM_N8LW_SIZE_DEVADDR; i++)
			{
				err = this->_GetReg('O', i+_ARM_N8LW_REGO_DEVADDR, ((uint8_t*)devAddr)+i);
				if(err != ARM_ERR_NONE)
					return err;
			}
		}
		
		if(devEui)
		{
           	
			for(i=0; i<_ARM_N8LW_SIZE_DEVEUI; i++)
			{
				err = this->_GetReg('O', i+_ARM_N8LW_REGO_DEVEUI, ((uint8_t*)devEui)+i);
				if(err != ARM_ERR_NONE)
					return err;
			}
		}
		
		if(appEui)
		{
           	
			for(i=0; i<_ARM_N8LW_SIZE_APPEUI; i++)
			{
				err = this->_GetReg('O', i+_ARM_N8LW_REGO_APPEUI, ((uint8_t*)appEui)+i);
				if(err != ARM_ERR_NONE)
					return err;
			}
		}
		
		if(appKey)
		{
           	
			for(i=0; i<_ARM_N8LW_SIZE_APPKEY; i++)
			{
				err = this->_GetReg('O', i+_ARM_N8LW_REGO_APPKEY, ((uint8_t*)appKey)+i);
				if(err != ARM_ERR_NONE)
					return err;
			}
		}
			
		if(nwkSKey)
		{
           	
			for(i=0; i<_ARM_N8LW_SIZE_NWKSKEY; i++)
			{
				err = this->_GetReg('O', i+_ARM_N8LW_REGO_NWKSKEY, ((uint8_t*)nwkSKey)+i);
				if(err != ARM_ERR_NONE)
					return err;
			}
		}

		if(appSKey)
		{
           	
			for(i=0; i<_ARM_N8LW_SIZE_APPSKEY; i++)
			{
				err = this->_GetReg('O', i+_ARM_N8LW_REGO_APPSKEY, ((uint8_t*)appSKey)+i);
				if(err != ARM_ERR_NONE)
					return err;
			}
		}
		
		//Quit AT commend
		return this->_BackAt();
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

armError_t Arm::UpdateConfig()
{
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		armError_t err = ARM_ERR_NONE;
		bool reConfigPort = false;
		int i = 0;
		
		//Find index of first registers changed.
		for(i=0; i<_ARM_N8LPLD_REGH_SIZE; i++)
		{
			if(this->_N8LPLD.regsH[i].newVal != this->_N8LPLD.regsH[i].val)
				break;
		}
		
		//Registers changed found?
		if(i<_ARM_N8LPLD_REGH_SIZE)
		{
			err = this->_GoAt();
			if(err != ARM_ERR_NONE)
				return err;
				
			//Write S register changed to arm
			for(; i<_ARM_N8LPLD_REGH_SIZE; i++)
			{
				//Set the new value if the value was changed. 
				if(this->_N8LPLD.regsH[i].newVal != this->_N8LPLD.regsH[i].val)
				{
					err = this->_SetReg('H', this->_N8LPLD.regsH[i].reg, this->_N8LPLD.regsH[i].newVal);
					if(err != ARM_ERR_NONE)
						return err;
						
					this->_N8LPLD.regsH[i].val = this->_N8LPLD.regsH[i].newVal;
					
					if(	(i >= _ARM_N8LPLD_IREGH_SERIAL_BAUDRATE) &&
						(i <= _ARM_N8LPLD_IREGH_SERIAL_STOPBIT))
						reConfigPort = true;
				}
			}
			err = this->_BackAt();
			if(err != ARM_ERR_NONE)
				return err;
		}
		
		//Need to reconfigure the port?
		if(reConfigPort)
		{
			armPortBaudrate_t baudrate;
			armPortDatabits_t databits;
			armPortParity_t parity;
			armPortStopbit_t stopbit;
			
			this->GetSerial(&baudrate, &databits, &parity, &stopbit);
			if(this->_port.Config(baudrate, databits, parity, stopbit) == -1)
				err = ARM_ERR_PORT_CONFIG;
		}
		
		return err;
	}
	#endif
	
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP1(N8_LW)
	{
		armError_t err = ARM_ERR_NONE;
		int im = 0;
		int io = 0;
		
		//Enable or Disable OTAA?
		if(	(this->_N8LW.regsO[_ARM_N8LW_IREGO_CONFIG].newVal&_ARM_N8LW_REGO_CONFIG_OTAA) !=
			(this->_N8LW.regsO[_ARM_N8LW_IREGO_CONFIG].val&_ARM_N8LW_REGO_CONFIG_OTAA))
		{
			uint8_t buf[32];
			int nread = 0;
	
			//Go to at commend.
			err = this->_GoAt();
			if(err != ARM_ERR_NONE)
				return err;
				
			//Enable or Disable OTAA
			io = _ARM_N8LW_IREGO_CONFIG;
			err = this->_SetReg('O', this->_N8LW.regsO[io].reg, this->_N8LW.regsO[io].newVal);
			if(err != ARM_ERR_NONE)
				return err;
							
			//Save the configuration 'ATOS'.
			nread = this->_WriteRead("ATOS\r", 5, buf, sizeof buf, _ARM_TIME_TIMEOUT);
			//Check reply
			if((memmem(buf, nread, "RAM => EEPROM", 13) == NULL))
				return ARM_ERR_ARM_CMD;
			
			//Reboot the ARM
			err = this->Reboot();
			if(err != ARM_ERR_NONE)
				return err;
		}
		
		//Find index of first registers M changed.
		for(im=0; im<_ARM_N8LW_REGM_SIZE; im++)
		{
			if(this->_N8LW.regsM[im].newVal != this->_N8LW.regsM[im].val)
				break;
		}
		
		//Find index of first registers O changed.
		for(io=0; io<_ARM_N8LW_REGO_SIZE; io++)
		{
			if(this->_N8LW.regsO[io].newVal != this->_N8LW.regsO[io].val)
				break;
		}
		
		//Registers changer ?
		if((im<_ARM_N8LW_REGM_SIZE) || (io<_ARM_N8LW_REGO_SIZE))
		{
			err = this->_GoAt();
			if(err != ARM_ERR_NONE)
				return err;

			//Registers M changed found?
			if(im<_ARM_N8LW_REGM_SIZE)
			{
				//Write S register changed to arm
				for(; im<_ARM_N8LW_REGM_SIZE; im++)
				{
					//Set the new value if the value was changed. 
					if(this->_N8LW.regsM[im].newVal != this->_N8LW.regsM[im].val)
					{
						err = this->_SetReg('M', this->_N8LW.regsM[im].reg, this->_N8LW.regsM[im].newVal);
						if(err != ARM_ERR_NONE)
							return err;
							
						this->_N8LW.regsM[im].val = this->_N8LW.regsM[im].newVal;
					}
				}
			}
			
			//Registers O changed found?
			if(io<_ARM_N8LW_REGO_SIZE)
			{
				//Write S register changed to arm
				for(; io<_ARM_N8LW_REGO_SIZE; io++)
				{
					//Set the new value if the value was changed. 
					if(this->_N8LW.regsO[io].newVal != this->_N8LW.regsO[io].val)
					{
						err = this->_SetReg('O', this->_N8LW.regsO[io].reg, this->_N8LW.regsO[io].newVal);
						if(err != ARM_ERR_NONE)
							return err;
							
						this->_N8LW.regsO[io].val = this->_N8LW.regsO[io].newVal;
					}
				}
			}
			
			err = this->_BackAt();
			if(err != ARM_ERR_NONE)
				return err;
		}
		
		return err;
	}
	#endif
	
	return ARM_ERR_NO_SUPPORTED;
}

int Arm::Send(const void* buf, size_t nbyte)
{
	int nwrite = 0;
		
	//Send all buf
	nwrite = this->_port.Write(buf, nbyte);
	
	return nwrite;
}

int Arm::Receive(void* buf, size_t nbyte, int timeout)
{
	size_t nread = 0;
	int n = 0;
	
	while(1)
	{
		//Read from the port
		n = this->_port.Read((uint8_t*)buf+nread, nbyte-nread, timeout);
		if(n == -1)
			return -1;
		else if(n == 0)
			return nread;
		
		nread += n;
	}
	
	return nread;
}

#ifndef __DOXYGEN__
uint8_t* Arm::_UintToStr(uint64_t val, uint8_t* str, uint8_t base, int n)
{	
	int i = 0;
	int nDigit = 0;
	uint8_t tmpDigit = 0;
	
	//Convert digits
	while(val)
	{
		tmpDigit = val%base;
		
		if(tmpDigit < 10)
			str[nDigit] = '0'+tmpDigit;
		else
			str[nDigit] = 'A'+tmpDigit-10;
		
		val /= base;
		nDigit++;
	}
	
	//Switch str 
	for(i=0; i<nDigit/2; i++)
	{
		tmpDigit = str[i];
		str[i] = str[nDigit-i-1];
		str[nDigit-i-1] = tmpDigit;
	}
	
	//Add '0' if necessary
	if(nDigit < n)
	{
		int nd = n-nDigit;
		for(i=nDigit-1; i>=0; i--)
			str[i+nd] = str[i];
		for(i=0; i<nd; i++)
			str[i] = '0';
			
		nDigit = n;
	}
	
	str[nDigit] = '\0';
	return str;
}

uint64_t Arm::_StrToUint(uint8_t* str, uint8_t base)
{	
	uint64_t val = 0;

	//Convert digits
	while(1)
	{
		if((*str >= '0') && (*str <= '9'))
		{
			val *= base;
			val += *str-'0';
		}
		else if((*str >= 'a') && (*str <= 'z'))
		{
			val *= base;
			val += (*str-'a')+10;
		}
		else if((*str >= 'A') && (*str <= 'Z'))
		{
			val *= base;
			val += (*str-'A')+10;
		}
		else
			break;
			
		str++;
	}
	
	return val;
}

int Arm::_Read(void* buf, size_t nbyte, unsigned int timeout)
{
	size_t nread = 0;
	int n = 0;
	size_t i = 0;
	
	while(1)
	{
		//Read from the port
		n = this->_port.Read((uint8_t*)buf+nread, nbyte-nread, timeout);
		if(n == -1)
			return -1;
		else if(n == 0)
			return nread;
		
		//Check if stop read condition
		for(i=nread; i<nread+n; i++)
		{
			if((((uint8_t*)buf)[i] == '\n') && (i>8))
			{
				nread += n;
				return nread;
			}
		}
		
		nread += n;
	}
	
	return nread;
}

int Arm::_WriteRead(const void* tbuf, size_t tnbyte, void* rbuf, size_t rnbyte, unsigned int rtimeout)
{
	//Write
	if(this->_port.Write(tbuf, tnbyte) != (int)tnbyte)
		return -1;
		
	//Read
	return this->_Read(rbuf, rnbyte, rtimeout);
}

armError_t Arm::_GoAt()
{
	uint8_t ntry = 0;
	uint8_t buf[40];
	int nread;
	
	while(ntry < _ARM_NUMBER_OF_TRIALS_GO_AT)
	{
		ntry++;
		
		//Write '+++' to go to AT commend and read reply
		#if defined ARM_WITH_N8_LPLD && !defined ARMPORT_WITH_nBOOT
		if(this->_type&(ARM_TYPE_NONE))
		{
			nread = this->_WriteRead("+++", 3, buf, sizeof buf, _ARM_N8LPLD_TIME_BOOTING/_ARM_NUMBER_OF_TRIALS_GO_AT);
			//Soit on est dans le boot du N8_LPLD ou deja en commend AT
			if(nread == 0)
			{
				this->_WriteRead("ATQ\r", 4, buf, sizeof buf, _ARM_TIME_TIMEOUT);
				continue;
			}
		}
		else
		#endif
			nread = this->_WriteRead("+++", 3, buf, sizeof buf, _ARM_TIME_TIMEOUT);
		
		if(nread < 0)
			return ARM_ERR_PORT_WRITE_READ;
			
		//If "a" is read, send "g" to quit bootloader.
		if((nread <= 3) && (buf[0] == 'a')) 
		{
			//Write 'g' to quit bootloader.
			this->_port.Write("g", 1);
			this->_port.Delay(_ARM_TIME_BOOTING);
		}
		//In AT commend if timeout or receive 3 char (3*'+')
		//or if "ARM" is read.
		else if(	(nread == 0) ||	(nread == 3) ||
			(memmem(buf, nread, "ARM", 3) != NULL)) 
			return ARM_ERR_NONE;
	}
	
	return ARM_ERR_ARM_GO_AT;
}

armError_t Arm::_BackAt()
{
	uint8_t buf[32];
	int nread = 0;
	
	//Write 'ATI' or 'ATQ' for back AT commend and read reply
	#ifdef ARM_WITH_N8_LPLD
	_ARM_IMP2(N8_LP, N8_LD)
	{
		nread = this->_WriteRead("ATI\r", 4, buf, sizeof buf, _ARM_TIME_TIMEOUT);
	}
	#endif
	
	#ifdef ARM_WITH_N8_LW
	_ARM_IMP2(NONE, N8_LW)
	{
		nread = this->_WriteRead("ATQ\r", 4, buf, sizeof buf, _ARM_TIME_TIMEOUT);
	}
	#endif
	
	if(nread < 0)
		return ARM_ERR_PORT_WRITE_READ;
		
	//Check reply
	if(	(memmem(buf, nread, "QUIT SETUP", 10) == NULL) &&
		(memmem(buf, nread, "Quit setup", 10) == NULL))
	{
		return ARM_ERR_ARM_BACK_AT;
	}
		
	//Wait ready
	if(this->_type&(ARM_TYPE_N8_LP|ARM_TYPE_N8_LD))
		this->_port.Delay(_ARM_TIME_BACK_AT+_ARM_REG8(N8LPLD, H, POST_TIME)*10);
	else
		this->_port.Delay(_ARM_TIME_BACK_AT);
	
	return ARM_ERR_NONE;
}

armError_t Arm::_GetReg(uint8_t type, uint8_t num, uint8_t* val)
{
	uint8_t rbuf[24];
	int nread;
	uint8_t* ptrrbuf = NULL;
	uint8_t tbuf[8] = "AT";
	
	//Create AT commend
	tbuf[2] = type;
	this->_UintToStr(num, tbuf+3, _ARM_BASE_DEC, 3);
	tbuf[6] = '\r';
	
	//Write AT commend and read reply
	nread = this->_WriteRead(tbuf, 7, rbuf, sizeof(rbuf)-1, _ARM_TIME_TIMEOUT);
	if(nread < 0)
		return ARM_ERR_PORT_WRITE_READ;
		
	//Check the message
	tbuf[6] = '=';
	rbuf[nread] = '\0';
	ptrrbuf = (uint8_t*)memmem(rbuf, nread, tbuf+2, 5);
	if(ptrrbuf == NULL)
		return ARM_ERR_ARM_GET_REG;
		
	//Convert the value
	ptrrbuf += 5;
	if(ptrrbuf[0] == '\0' && ptrrbuf[1] == '\0')
		return ARM_ERR_ARM_GET_REG;
	*val = this->_StrToUint(ptrrbuf, _ARM_BASE_HEX);
	
	return ARM_ERR_NONE;
}

armError_t Arm::_SetReg(uint8_t type, uint8_t num, uint8_t val)
{
	uint8_t rbuf[24];
	int nread;
	uint8_t tbuf[10] = "AT";
	
	//Create AT commend
	tbuf[2] = type;
	this->_UintToStr(num, tbuf+3, _ARM_BASE_DEC, 3);
	tbuf[6] = '=';
	this->_UintToStr(val, tbuf+7, _ARM_BASE_HEX, 2);
	tbuf[9] = '\r';
		
	//Write AT commend and read reply
	nread = this->_WriteRead(tbuf, 10, rbuf, sizeof rbuf, _ARM_TIME_TIMEOUT);
	if(nread < 0)
		return ARM_ERR_PORT_WRITE_READ;
		
	//Check the message
	if(memmem(rbuf, nread, tbuf+2, 7) == NULL)
		return ARM_ERR_ARM_SET_REG;
	
	return ARM_ERR_NONE;
}

#endif //__DOXYGEN__

